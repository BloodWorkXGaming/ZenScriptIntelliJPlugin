{
    parserClass="de.bloodworkxgaming.zenscript.plugin.zsLanguage.parsing.ZsParser"
  parserUtilClass="de.bloodworkxgaming.zenscript.plugin.zsLanguage.parsing.ZsParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Zs"
    psiImplClassSuffix="Impl"
    psiPackage="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi"
    psiImplPackage="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.impl"

    elementTypeHolderClass="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.ZsTypes"
    elementTypeClass="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.ZsElementType"
    tokenTypeClass="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.ZsTokenType"

    psiImplUtilClass="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.impl.ZsPsiImplUtil"

    tokens = [
        // characters
        L_ROUND_BRACKET         = "("
        R_ROUND_BRACKET         = ")"
        L_ANGLE_BRACKET         = "<"
        R_ANGLE_BRACKET         = ">"
        L_SQUARE_BRACKET        = "["
        R_SQUARE_BRACKET        = "]"
        L_CURLY_BRACKET         = "{"
        R_CURLY_BRACKET         = "}"


        EQUAL           = "="
        EXCL            = "!"
        TILDE           = "~"
        QUEST           = "?"
        COLON           = ":"
        PLUS            = "+"
        MINUS           = "-"
        ASTERISK        = "*"
        DIV             = "/"
        OR              = "|"
        AND             = "&"
        XOR             = "^"
        PERC            = "%"
        AT              = "@"
        HASH            = "#"

        SEMICOLON       = ";"
        COMMA           = ","
        DOT             = "."

        EQEQ            = "=="
        NOT_EQUAL       = "!="
        LESS_EQUAL      = "<="
        GREATER_EQUAL   = ">="

        LINE_COMMENT    = 'regexp://.*'
        BLOCK_COMMENT   = 'regexp:/\*([^*]|\*+[^*/])*(\*+/)?'

        DOUBLE_QUOTED_STRING = "regexp:\"([^\\\"\r\n]|\\[^\r\n])*\"?"
        SINGLE_QUOTED_STRING = "regexp:'([^\\\'\r\n]|\\[^\r\n])*'?"

        DIGITS          = "regexp:-?[0-9]+"
        FLOATING_POINT  = "regexp:{DIGITS}\.[0-9]+"

        // types
        ANY         = "any"
        BOOL        = "bool"
        BYTE        = "byte"
        SHORT       = "short"
        INT         = "int"
        LONG        = "long"
        FLOAT       = "float"
        DOUBLE      = "double"
        STRING      = "string"

        // control structure
        FUNCTION    = "function"
        IN          = "in"
        TO          = "to"
        VOID        = "void"
        AS          = "as"
        VERSION     = "version"
        IF          = "if"
        ELSE        = "else"
        FOR         = "for"
        RETURN      = "return"
        IMPORT      = "import"

        VAR         = "var"
        VAL         = "val"

        // constants
        NULL        = "null"
        TRUE        = "true"
        FALSE       = "false"

        EOL         = "regexp:\R"
        IDENTIFIER  = "regexp:[:jletter:] [:jletterdigit:]*"
   ]
}

zsFile ::= preprocessor_list? import_list (statement | function_declaration )*

// private item_ ::=

preprocessor_list ::= preprocessor*
preprocessor ::= HASH IDENTIFIER*

import_list ::= import_statement*
import_statement ::= IMPORT IDENTIFIER (DOT IDENTIFIER)* SEMICOLON

// general statement that is valid on it's own
statement ::= assignStatement SEMICOLON
              | EOL
              | functionCall SEMICOLON
              | for_loop
              | if_statement /*{recoverWhile=statement_recover}*/

private statement_recover ::= SEMICOLON



bracketHandler ::= L_ANGLE_BRACKET (IDENTIFIER | COLON | DIGITS | ASTERISK)* R_ANGLE_BRACKET
variable ::= IDENTIFIER {methods= [getName getNameIdentifier setName]
                         implements="de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.ZsNamedElement"
                         mixin= "de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.impl.ZsNamedElementImpl"}
class_name ::= IDENTIFIER (L_SQUARE_BRACKET R_SQUARE_BRACKET)*

number ::= DIGITS | FLOATING_POINT


validVariable ::= lambda_function_declaration
                  | castExpression
                  | equation
                  | bracketHandler
                  | functionCall
                  | field_reference
                  | variable
                  | number
                  | NULL
                  | DOUBLE_QUOTED_STRING
                  | SINGLE_QUOTED_STRING
                  | arrayDeclaration
                  | arrayRead
                  | moduloType
                  | TRUE
                  | FALSE

validCallable ::= bracketHandler
                  | variable
                  | DOUBLE_QUOTED_STRING
                  | SINGLE_QUOTED_STRING
                  | arrayRead

field_reference ::= validCallable (DOT IDENTIFIER)*

moduloType ::= (bracketHandler | variable)PERC DIGITS

assignStatement ::= (VAR | VAL)? field_reference EQUAL validVariable /*{mixin= "de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.impl.ZsNamedElementImpl"
                                                               implements= "de.bloodworkxgaming.zenscript.plugin.zsLanguage.psi.impl.ZsNamedElementImpl"
                                                               methods=[getVariableName getNameIdentifier setVariableName]}*/
functionCall ::= validCallable ((DOT IDENTIFIER)* (L_ROUND_BRACKET R_ROUND_BRACKET | (L_ROUND_BRACKET (validVariable (COMMA validVariable)*) R_ROUND_BRACKET)))+

arrayDeclaration ::= L_SQUARE_BRACKET validVariable (COMMA validVariable)* R_SQUARE_BRACKET
arrayRead ::= IDENTIFIER (DOT IDENTIFIER)* (L_SQUARE_BRACKET DIGITS R_SQUARE_BRACKET)+

castExpression ::= (arrayDeclaration | IDENTIFIER | bracketHandler) AS class_name

// CONTROL STATEMENTS
statement_body ::= (L_CURLY_BRACKET statement* R_CURLY_BRACKET | function_body)
return_statement ::= RETURN validVariable SEMICOLON

for_loop ::= FOR (((variable COMMA)? variable in variable) | (variable IN DIGITS ((DOT DOT) | TO) DIGITS)) statement_body

condition ::= validVariable ((EQEQ | NOT_EQUAL | GREATER_EQUAL | LESS_EQUAL | L_ANGLE_BRACKET | R_ANGLE_BRACKET) validVariable)*

if_statement ::= IF L_ROUND_BRACKET condition ((OR | AND | XOR) condition)* R_ROUND_BRACKET statement_body (ELSE statement_body)?

function_declaration ::= FUNCTION IDENTIFIER ((L_ROUND_BRACKET parameter_list R_ROUND_BRACKET) | (L_ROUND_BRACKET R_ROUND_BRACKET)) (AS class_name)? function_body
lambda_function_declaration ::= FUNCTION ((L_ROUND_BRACKET parameter_list R_ROUND_BRACKET) | (L_ROUND_BRACKET R_ROUND_BRACKET)) (AS class_name)? function_body

parameter_list ::= (parameter_variable COMMA)* parameter_variable
parameter_variable ::= (variable (AS class_name)?)
function_body ::= L_CURLY_BRACKET statement* return_statement? R_CURLY_BRACKET

//TODO: possibly replace with external code, does not support brackets this way
equation ::= unary_math_signs? valid_calculation_variable (binary_math_signs unary_math_signs? valid_calculation_variable)+

private valid_calculation_variable ::= bracketHandler
                                       | functionCall
                                       | number
                                       | arrayRead
                                       | variable
private binary_math_signs ::= PLUS MINUS | ASTERISK | DIV
private unary_math_signs ::= EXCL